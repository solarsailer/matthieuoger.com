---
date: "2019-08-01"
title: "Fast"
excerptQuote:
  name: "Craig Mod"
  quote: "I love fast software. That is, software speedy both in function and interface. […] To me, speedy software is the difference between an application smoothly integrating into your life, and one called upon with great reluctance. […] Ultimately, to be fast is to be light."
---

Craig Mod in “[Fast Software, the Best Software](https://craigmod.com/essays/fast_software/)”:

> I _love_ fast software. That is, software speedy both in function and interface. Software with minimal to no lag between wanting to activate or manipulate something and the thing happening. Lightness.
>
> Software that’s speedy usually means it’s focused. Like a good tool, it often means that it’s simple, but that’s not necessarily true. Speed in software is probably the most valuable, least valued asset. To me, speedy software is the difference between an application smoothly integrating into your life, and one called upon with great reluctance.
>
> […] Because — it’s not _quite_ as fast. We’re talking milliseconds, but it’s enough that you _feel_ the difference.
>
> […] Still, the slowness feels indicative of unseen rot on the inside of the machine. The slowness is like an off smell. I don’t trust the application as much as I would if it didn’t slow down […]
>
> Speed and reliability are often intuited hand-in-hand. Speed can be a good proxy for general engineering quality. If an application slows down on simple tasks, then it can mean the engineers aren’t obsessive detail sticklers. Not always, but it can mean disastrous other issues lurk. I want all my craftspeople to stickle.
>
> […] I love software that does this: Software that unbloats over time. This should be the goal of all software. The longer it’s around, the more elegant it should become. Smooth over like a river stone.
>
> […] But why is slow bad? Fast software is not always good software, but slow software is rarely able to rise to greatness. Fast software gives the user a chance to “meld” with its toolset. That is, not break flow.
>
> […] It feels — intuitively — that software (beyond core functionality) should aim for speed. Speed as a proxy for efficiency. […]
>
> _Ultimately, to be fast is to be light._

He's talking about software — where it's most perceptible —, but I think this could also be easily applied to physical objects.

---

As an aparté, but similarly, Craig also wrote this sentence that I like a lot in his [latest Roden newsletter](https://craigmod.com/roden/028/):

> Part of me wishes there was more of a trend in the startup world to build sustainably small, single-serving, hyper-focused, _culturally-impactful_ businesses.

---

## Update <span class="more">28 August 2019</span>

Related to this topic, [John Siracusa](https://overcast.fm/+R7DVyEUt0/1:37:42) in [episode #337 of ATP](https://atp.fm/episodes/337):

::: blockquote transcript
That's what I want. I don't want to be waiting for the computer for things that I shouldn't have to be waiting for the computer for. For small interactive things. That involves, like, it's not saying "oh yes, eliminate animations because it takes too long". I just want everything to be interactive… all the time.

I want it to be responsive to my input.
:::

This really is the crux of the problem. As soon as you start your actions and you have to stop because the software is not able to follow you, it's over (exhibit A: Jira, or as [John's co-host says…](/sounds/posts/2019-08-01-fast/jira.mp3)).
